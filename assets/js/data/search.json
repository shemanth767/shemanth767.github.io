[ { "title": "Replacing Google Drive with NextCloud - Part 2", "url": "/posts/Replacing-Google-Drive-2/", "categories": "Server", "tags": "", "date": "2022-09-18 10:00:00 +0530", "snippet": "OverviewI‚Äôve finally settled on a framework that works for me reliably. It has a lot of moving parts, but AWS made itso simple to manage and synchronize them.DescriptionEC2 InstanceEC2 Instance is the t3a.small server that I‚Äôm renting to run NextCloud on. It contains 2 vCPUs and 2GB of Memory.I think T3 is the best tool for my use case here. In the words of Amazonitself, T3 instances are designed for applications with moderate CPU usage that experience temporary spikes in use.1 ‚Äì NextCloudThis is the heart of everything. It‚Äôs the main NextCloud application.2 ‚Äì MySQL DBNextCloud maintains a local disk DB that keeps track of the metadata for files updated i.e., the name of each file, when itwas uploaded, directory path etc. Optionally, this DB can also store the thumbnails of images so that users can onlyget the whole image when needed.3 ‚Äì Redis CacheTo serve frequently accessed files quickly, NextCloud maintains a cache in Redis.4 ‚Äì Apache ServerThe final piece of the core NextCloud infrastructure is an apache server for the NextCloud Web application and APIs. Thisallows seamless connectivity from NextCloud‚Äôs Android app!5 ‚Äì Static IPAWS gives one free static IP for every running EC2 instance. You get charged hourly if you have the static IP, but the EC2instance is shut down. This becomes important in the cost analysis :/Data Layer6 ‚Äì S3 Storage BucketNextCloud is configured to store all files in an S3 Bucket. Accesses from this bucket are relatively slow when comparedto disk fetches, so Redis comes in handy here. This bucket can grow infinitely (not really), so scalability FTW.7 ‚Äì S3 Access Logs BucketThis is an optional element where access logs to the main bucket are stored.8 ‚Äì Offline BackupsThis is a optional and manual backup I‚Äôve configured to sync data from the bucket onto my local disk. Can‚Äôt be too cautious.Other Infra9 ‚Äì Lambda FunctionsEC2 Instances are charged by the hour. So, if I can schedule the hours in which my instance should be up, I cansignificantly cut down costs. This is done by the lambda functions, StartNCInstance - Starts this particular instance StopNCInstance - Stops this particular instance10 ‚Äì EventBridgeLambda Functions cannot run themselves and need an external trigger. EventBridge lets me trigger the configured lambdafunctions using a cron trigger. Following are the triggers I have configured, StartNCInstance - 30 2 * * ? * - Triggers the corresponding Lambda function at 02:30 UTC daily (8AM IST). StopNCInstance - 30 12 * * ? * - Triggers the corresponding Lambda function at 12:30 UTC daily (6PM IST).This setup keeps my instance up for 10 hours a day.Cost AnalysisBreakdownEC2 InstanceMonthly Hours: 30 Days * 10 Hours per day = 300 HoursCost per Hour: 0.0123$Actual Monthly Cost: 3.69$EBS StorageThe disk that EC2 uses is an Elastic Block Storage which is also charged. However, it‚Äôs free for the first 12 months!Size: 16GBCost per GB-Month: 0.114$Estimated Monthly Cost: 1.82$Actual Monthly Cost: 0$ (Free-tier!)Elastic IP AddressAs mentioned before, the static IP Address is free whenever it‚Äôs attached to an active EC2 Instance. So, only the hourswhen the IP is not attached to a running instance is billed.Monthly Hours: 30 Days * 14 Hours per day = 420 HoursCost per Hour: 0.005$Actual Monthly Cost: 2.1$S3 Storage5GB Storage per month is free for the first twelve months.Average Monthly Storage: 10GBCost per GB-Month: 0.025$Estimated Monthly Cost: 0.25$Actual Monthly Cost 0.125$S3 Get RequestsI was surprised to learn that S3 bills for the number of requests you make to the storage. The free tier subsidies 20,000GET requests per month.Average GET Requests: 6,000Cost per 1,000 GET Requests 0.0004$Estimated Monthly Cost: 0.0024$Actual Monthly Cost: 0$S3 PUT, COPY, and POST RequestsThe free tier subsidies 2,000 PUT requests per month.Average Requests: 3,000Cost per 1,000 Requests 0.005$Estimated Monthly Cost: 0.015$Actual Monthly Cost: 0.005$LambdaAWS gives out 3.2 Million seconds of compute time and 1 Million free requests per month. This is ALWAYS FREE :)Requests per month: (2 per day) * (30 days) = 60 RequestsCompute seconds per month: (60 Requests) * (600 ms average) = 36 SecondsEstimated Monthly Cost: Don‚Äôt bother with this. It‚Äôs less than a cent.Actual Monthly Cost: 0$ (Free-tier!)Event BridgeIt‚Äôs free.Total Costs Service Estimated Cost Actual Cost EC2 3.69 3.69 EBS 1.82 0 Elastic IP 2.1 2.1 S3 0.25 0.125 S3 GET 0.0024 0 S3 POST 0.015 0.005 Lambda 0 0 EventBridge 0 0 Total Estimated Monthly Cost: 7.87$Total Actual Monthly Cost: 5.92$Google One gives 100GB of Storage at Rs. 120 per month. My setup is 4 times more expensive.I can never ever compete with Google‚Äôs economies of scale!" }, { "title": "Replacing Google Drive with NextCloud - Part 1", "url": "/posts/Replacing-Google-Drive-1/", "categories": "Server", "tags": "", "date": "2022-07-31 19:00:00 +0530", "snippet": "OverviewThis article summarizes my descent into insanity and the following events that transpired on 30thJuly 2022. More formally, as I had mentioned in my previous blog post, I was looking to replace Google Drive and Photoswith something self hosted and OSS. It was also the right time as I was bumping against the 15GB free limit on myGoogle Drive. I‚Äôve been following Nextcloud for a while now, as I‚Äôve heard it to bereliable and easy to set up.My goals are, Reliability Security Responsiveness Cost EffectivenessPreparing my existing serverI‚Äôve been using a Digital Ocean droplet (a Virtual Private Server) for the past 2 years to host Bitwardenpassword manager and some ad-hoc testing for ongoing projects.Digital Ocean server configurationCouple of things to note, TOR1 is a datacenter in Toronto, Canada. Toronto is quite far from Hyderabad in terms of network latency, which is not a concern for Bitwarden as the mobile app and extension cache the password vault frequently. Memory of 2GB - The absolute minimum required for installing Bitwarden. 50GB Disk - This was originally only 25GB because why would a password manager need more?Okay, first problem to tackle.Problem #0: Setting up SSH login to the serverI‚Äôve recently migrated to a new PC, so I had to enable SSH login from this one. It was a very straight-forward process. Copy over public key from local to remote server‚Äôs /root/.ssh/authorized_keys Restart ssh daemon, service sshd restart SSH into the server.Problem #1: Change the domain name of the serverI had an A record configured on Bluehost to point ‚Äúverylongname.saihemanth.com‚Äù to the static IPof my server. Purely for aesthetic reasons, I wanted to change it to ‚Äúshort.saihemanth.com‚Äù instead.Updating the DNS record barely took 10 mins.DNS Record for new short domain nameBitwarden turned out to be a pain in the ass while switching domain names. Specifically, it was thebuilt-in certbot. It was supposed to be a single config change in /opt/bitwarden/bwdata/config.yml andrestart, ./bitwarden.sh restart. This worked, but the generated SSL certificates were still linked to the old domain.I thought, ‚ÄúOkay, no problem. Let me just trigger the renew certificate command. It should pick up the newdomain name from config. Right?‚Äù Wrong!Certbot proceeded to use the old URL!I deleted all certificate files used specifically by certbot in the hopes that it‚Äôll try to pick up the correctdomain name from config next time. That still didn‚Äôt work. I struggled with fixing this for over an hour!With no other resort, I exported all my passwords using the Bitwarden Web UI and uninstalled bitwarden:./bitwarden.sh uninstall. Reinstalling the entire setup and importing my exported passwords took less than20 mins.Not elegant, but problem solved!NextCloudProblem #2: Setting up NextcloudI took a backup of the droplet to start with ‚Äî in case I brick the server. DigitalOcean bills me for keeping backups too.Thanks, DO üëç Installing NextCloud itself was very simple. I just had to follow nextcloud all-in-one‚Äôs README. What does all-in-one mean? I didn‚Äôt know, I only needed the cloud storage functionality, and AIO was easy to set up. sudo docker run -it \\ --name nextcloud-aio-mastercontainer \\ --restart always \\ -p 80:80 \\ -p 8080:8080 \\ -p 8443:8443 \\ --volume nextcloud_aio_mastercontainer:/mnt/docker-aio-config \\ --volume /var/run/docker.sock:/var/run/docker.sock:ro \\ nextcloud/all-in-one:latest Next step, I opened the AIO (all-in-one) interface at short.saihemanth.com:8443. This webpage gave me the default admin password and redirected me to an installation page. It asked for a valid domain name with port 443 open and a valid SSL to be used for NextCloud. The domain was quickly verified and accepted by the tool! I started all the required nextcloud docker containers through the UI and waited for the containers to come up. They never did. The apache docker container logs gave me this error, cURL error 35: OpenSSL SSL_connect: SSL_ERROR_SYSCALL in connection to &amp;lt;domain&amp;gt;:443. Took a while to figure out, but I realized it‚Äôs a memory issue. Bitwarden‚Äôs containers were struggling for resources alongside the newly bought up NextCloud containers. NextCloud‚Äôs Redis container was in particular failing, and the Apache container was waiting for the database to be up. So, no NextCloud for me. I resized the droplet to 2vCPUS, 4GB memory, and 50GB Disk and followed from step 1 again. It all worked flawlessly now! I quickly set up 2FA for the admin account, and created a different personal user account for daily use.After 4 hours, I finally have a working NextCloud instance running! (Not Really)Problem #3: Setting up BackupsNextCloud AIO doesn‚Äôt seem to have support for automated backups. Admin needs to explicitly generate backups byclicking a button in settings, upon which an encrypted backup is created and stored. I would‚Äôve likedsomething automated, but I wasn‚Äôt too eager to explore more. Upon generating backups through the UI, they land as encrypted files in ‚Äú/root/nextcloud_backup‚Äù directory. This works fornow. I need to sync these backups from the DO droplet to my local backup disk. What better tool than rsync? I rsynced with archiving and compressing enabled to hopefully make it faster. rsync -avzh root@100.101.102.103:/root/nextcloud_backup /backup-disk/remote_backup/nextcloud_backup The files were downloading at 25KBps! It will take forever to download 15GB backups. This speed was abysmal and barelyviable as a solution. I forboded to one of the reasons before. This server is all the way in Canada, and thistrans-continental data transfer was poor. However, I partially felt it also had to do with DigitalOcean itself.Migrating to AWSProblem #4: Improve transfer speedsThere were a couple of reasons why I wanted to dabble with AWS, Cheaper Servers - AWS VPSs are about 5\\$ cheaper compared to a similar configuration in DO. The exact setup is 20\\$ on AWS Lightsail, while DO was 24\\$ per month. Better Integrations - AWS is known for its wide variety of services and integrations, and I believed they could aid me later. Curiosity - I probably could do something similar on DigitalOcean, but I wanted to play with AWS and see what AWS is all about.Everything after this was smooth, Started a lightsail instance in Mumbai datacenter with 2GB RAM and 1vCPU. This config‚Äôs free for 3 months. Setup the network config, Open ports 443, 8080, and 8443 on both TCP and UDP. Create a static IP and attach it to the instance. Add DNS mapping for this static IP on Bluehost. Follow all steps from Problem #2 to install and set up NextCloud AIO.Once again, I finally have a working NextCloud instance running!Problem #5: Stress Testing &amp;amp; Performance8 hours in.I downloaded 600MB worth of pictures from Google Photos and tried uploading them to NextCloud. The apppromptly became unresponsive and crashed. I couldn‚Äôt SSH into the server either. Nice üëå.It was clear that 1vCPU was insufficient for this instance, so I bumped it up to 2vCPUs and 4GB RAM. UnlikeDigitalOcean, AWS had no option to resize the existing server itself. I had to create a new larger lightsail instanceusing a backup of the previous one.One other observation I had was that NextCloud does not send previews for gallery views by default. It insteadsends over the entire image! One way to circumvent this is to use thepreviewgenerator NextCloud app.This requires a cron job to continuously generate previews for any recently uploaded media.*/10 * * * * docker exec -it &amp;lt;docker-process-id&amp;gt; ./occ preview:pre-generateI tried out rsync of backups similar to before, and this time it downloads at 8MBps!Okay, I finally finally have a working NextCloud instance! For real.RetrospectiveComparing my final setup against the goals I set initially.üîò ReliabilityI‚Äôm not happy with storing my files in the instance‚Äôs disk. It seems fragile and bound to fail at some point.Increasing storage also requires me to bump up the instance‚Äôs config, which is far from ideal. For e.g., the currentlightsail instance comes with 80GB disk. If I need more space, I‚Äôll have to increase the VPS‚Äôs specs including vCPUs.If the server dies, I have mechanisms to recover the setup using a backup. Creating and syncing backups is alow effort task. However, I might lose the recent uploads that aren‚Äôt backed up. There‚Äôs scope for improvement here.‚òëÔ∏è SecurityI don‚Äôt see any obvious security flaws here. Running NextCloud Scan gives an A rating.There‚Äôs SSL in place. Only required ports are open. There‚Äôs probably more I can do here, but they only yielddiminishing returns.‚òëÔ∏è ResponsivenessAfter I moved to AWS Lightsail, the website and Android app are blazing fast. The uploads happen at upwards of 8MBps,and the experience is super smooth.‚ùå Cost EffectivenessThe entire setup is just one Lightsail instance. The lightsail instance (2vCPUs/4GB/80GB Disk)costs \\$20 per month. In contrast, Google One subscription costs Rs.135 in India, \\$1.7.I cannot justify having a feasible replacement if it costs 11 times more!Stay tuned for Part 2 of this series! Follow me on Twitter for more :)" }, { "title": "Building a Home Server - Part 1", "url": "/posts/Building-PC-1/", "categories": "Programming", "tags": "", "date": "2022-04-01 09:00:00 +0530", "snippet": "ObjectivesAs a privacy nut, I‚Äôm not comfortable storing GBs of photos, videos, and documents on OneDrive and Google Drive. My mostpersonal memories locked away in some heartless data warehouse, possibly used for advertising.I‚Äôve been toying with the idea of replacing all of my cloud-based applications with somethingcustom-built. This includes Google Photos, Google Drive, One Drive, and Digital Ocean VMs.To summarize, A place to save photos, videos, and files reliably and redundantly A web server A dev VM A password manager serverOf course, the main goal is to have fun and learn :)Choosing the HardwareThe scale of my requirements is pretty minimal, so I don‚Äôt need a dedicated server PC. I can‚Äôt usea pre-built NAS either as it isn‚Äôt customizable enough. So, I decided to builda consumer PC. As a regular LTT viewer, I have basic knowledge of PC building.ProcessorThis minimal server does not really require large core/thread counts or high frequency cores. So, I decided tosettle on the affordable Intel i5-11400 2.6GHZ processor. It has 6 cores and 12 threads. This CPU comeswith an integrated graphics card. Also, it cannot be overclocked, which is fine because I don‚Äôt wantto spend time thinking about efficient cooling.Amazon Link: https://www.amazon.in/gp/product/B08X6JPK4KMemoryIdeally, I should get 32GB of DDR4 ECC RAM. However, it‚Äôs expensive and hard to get ECC supported RAM, CPU, andmotherboard in India. Non-ECC RAM sticks are generally unlikely to fail, and I‚Äôll be relying on backups extensively. I‚Äôve settledon using two 8GB G Skill Ripjaws 3200MHz DDR4 RAM Sticks. I can expand to 32GB in the future.Amazon Link: https://www.amazon.in/gp/product/B01J6OA8RUGraphics CardA server doesn‚Äôt need one. The integrated graphics card in the i5 processor should more than do the job.I considered chucking in a 2060 to play Minecraft when I‚Äôm free, but all GPUs are heavily scalped right now :(StorageI need fast storage. So, I‚Äôm buying two Samsung 970 Evo Plus 500GB M.2 SSDs. One will be used for Host OS and VM Images.Another will probably host all the required fast-access data. I haven‚Äôt nailed down the specifics yet. I need to buytwo 5TB HDDs to store backups, images, and videos later.Amazon Link: https://www.amazon.in/gp/product/B07MFBLN7KMotherboardChoosing this was the hardest. I wanted to maximize for the M.2 slots and SATA ports available. I ended up withASUS TUF Gaming B560M-Plus WiFi mATX Motherboard. It has two M.2 slots, Six SATA ports and Thunderbolt 4 port.Amazon Link: https://www.amazon.in/gp/product/B08CMVNJ58Power SupplyThe CPU I‚Äôve chosen is a 65W CPU and I don‚Äôt need a dedicated GPU. So, my power requirements are pretty light. I‚Äôve decidedto go with a Corsair non-modular 550W PSU. It‚Äôs cheap and allows for future expansions, in case I decide to pop in an Nvidia 2000series graphics card.Amazon Link: https://www.amazon.in/gp/product/B07YVVNK6YCaseAny mid-tower case that could fit an mATX motherboard was sufficient for me. I went with the popular Corsair 4000D Airflow case.It has two 2.5‚Äù SATA SSD mounts and two 3.5‚Äù HDD bays. If I ever need more disks, which will not be the case for the next few years,I‚Äôll change the case.Amazon Link: https://www.amazon.in/gp/product/B08C7BGV3DBuilding the PCAssembling the PC itself was pretty straightforward. Linus Tech Tips has some great PC Building guides, especially this recent one.After getting some thermal paste on my hands, fearing I‚Äôll damage the board by pressing on the RAM sticks too hard, strugglingto figure out where to mount the motherboard in case, and struggling to keep the cables tucked in neatly, I managed to get it workingon the first try.And... Done. pic.twitter.com/0oBJXqgZA7&amp;mdash; Sai Hemanth (@saihemanth9019) March 26, 2022" }, { "title": "I finally understand Declarative Programming", "url": "/posts/I-Finally-Understand-Declarative/", "categories": "Programming", "tags": "", "date": "2022-01-29 09:00:00 +0530", "snippet": "BackgroundDiscussions surrounding declarative and functional programming have been on the rise over the past few years. Out ofcuriosity, I started reading articles to understand how to reap the promised magical benefits. Just like how onedoesn‚Äôt learn to swim by reading about it, I couldn‚Äôt understand the essence of declarative programming irrespectiveof how many YouTube videos I watched. In computer science, declarative programming is a programming paradigm ‚Äî a style of building the structure andelements of computer programs ‚Äî that expresses the logic of a computation without describing its control flow.‚Äî WikipediaThis definition abstractly made sense, but aren‚Äôt you supposed to define the control flow somewhere? Aren‚Äôt we supposedto iterate and update variables at someplace for the program to work? I was so caught in thinking of programs as blocksof explicit control flow that I simply couldn‚Äôt look outside of it.Deciding I wanted to get knee-deep into this mysterious paradigm, I solved some problems inAdvent of Code twice, once using an imperative language, and again using a declarativelanguage. The first challenge was to choose appropriate languages for both these paradigms. Most popular languagesare not of one type or the other. They are on a spectrum. (More on that in later sections)C++ is my choice for imperative because it is the least declarative programming language I‚Äôve used (No offense). Ichose Haskell as the declarative language because I‚Äôve wanted to learn the language for years. Technically, it‚Äôs afunctional programming language, which is a type of declarative. By the way,‚ÄúLearn you a Haskell for Great Good‚Äù is an amazing source to learn Haskell.As I finish this journey, I‚Äôve documented my learnings in this article. I hope this becomes the article I wish I hadfound when I started.DisclaimerTo emphasize the difference between these paradigms, I‚Äôve only used rudimentary C++ in most examples. No STL, etc.The examples do not compare Haskell and C++ code, instead imperative and declarative programs. It is possible to writeSTL based succinct C++ code, but it doesn‚Äôt help understand the essence of imperative.LessonsThe program approaches the human language solutionConsider the following task,Given a list of numbers, remove all numbers which are 0 and sort the remaining.For example, given [5, 0, 8, 0, 0, 2] the program should return [2, 5, 8]. Following is the solution in C++,vector&amp;lt;int&amp;gt; filterAndSort(vector&amp;lt;int&amp;gt; arr) { vector&amp;lt;int&amp;gt; result; int n = arr.size(); for (int i = 0; i &amp;lt; n; i++) { if (arr[i] != 0) result.push_back(arr[i]); } // Bubble Sort int m = result.size(); for (int i = 0; i &amp;lt; m; i++) { for (int j = i+1; j &amp;lt; m; j++) { if (result[i] &amp;gt; result[j]) swap(result[i], result[j]); } } return result;}Create an empty vector called result. Iterate over every index (i) from 0 to n of the input array and check if thearray element at index is not 0. If the element is non-zero, push the element to the end of result vector. Assign thesize of the filtered vector to variable m. Iterate over each element in index (i) of result vector and over eachindex (j) starting from i+1 to end of array. If element at index i is greater than element at index j, swap the twoelements in the result array. Return the final sorted result vector.That‚Äôs a LOT of words for a problem whose solution can be explained to my rubber duck in one line.This is the solution in Haskell,filterAndSort = sort . filter (/= 0)Even with no prior knowledge of Haskell syntax, one can see that the function does two things ‚Äî filter and sort.This function reads as ‚Äúfilter a list by retaining all elements not equal to zero (/= 0) and sort the remaining list‚Äù.The task statement requires me to do two things, and the Haskell function does exactly two things.This is the crux of Declarative Programming. The program should roughly be the human language explanation of thesolution. It expresses what it does, instead of how to do it. Stuff like iteration and updating variables isimplementation detail that should be hidden.Modern C++ has functions that can help abstract away some of the clutter. However, there will still be implementationdetail that does not belong to the problem statement.vector&amp;lt;int&amp;gt; filterAndSort(vector&amp;lt;int&amp;gt; arr) { vector&amp;lt;int&amp;gt; result; for (auto item : arr) { if (item != 0) { result.push_back(item); } } sort(result.begin(), result.end()); return result;}Building upon the earlier definition, one might say that declarative programming is simply about having a ton ofutility functions. That‚Äôs only a part of it. Having a good number of utility functions definitely helps abstractaway implementation detail. However, it goes even deeper. Let‚Äôs try to solve the following problem,Given two characters, return true if the first one is an opening bracket and the second one is the matching closingbracket. Return false, otherwise.Following is the solution in C++,bool areMatching(char a, char b) { if (a == &#39;(&#39; &amp;amp;&amp;amp; b == &#39;)&#39;) return true; if (a == &#39;[&#39; &amp;amp;&amp;amp; b == &#39;]&#39;) return true; if (a == &#39;{&#39; &amp;amp;&amp;amp; b == &#39;}&#39;) return true; if (a == &#39;&amp;lt;&#39; &amp;amp;&amp;amp; b == &#39;&amp;gt;&#39;) return true; return false;}For a C++/Java programmer, this looks perfectly sensible and readable. Now, let‚Äôs see the Haskell solution,areMatching &#39;(&#39; &#39;)&#39; = TrueareMatching &#39;[&#39; &#39;]&#39; = TrueareMatching &#39;{&#39; &#39;}&#39; = TrueareMatching &#39;&amp;lt;&#39; &#39;&amp;gt;&#39; = TrueareMatching _ _ = FalseareMatching is a function that takes two parameters. By virtue of pattern matching, we can create multipledefinitions of the same function for different values of parameters. The final function definition is the fallbackwhen none of the earlier ones match. This is the closest you can get to the problem statement.Declarative programming is a race to make programs comprehensible even to non-programmers. Every other jargon youhear surrounding declarative programming are only means to achieve this goal.Ability to express logic effortlesslyTo write programs declaratively, a language should allow users to compose and reuse elements fluently. The fundamentalbuilding block of Haskell is a function. It is simple to compose different functions into one ‚Äî which makes forprograms that require very little overhead beyond the problem domain.-- Returns the product of the largest three numbers in an unsorted listproductLarge3 = product . (take 3) . reverse . sort-- Returns all pairs of coordinates (0,0), (0,1) .. (0,n-1), (1,1) ... (n-1,n-1) given n-- Similar to mathematical set comprehension.getAllCoordinates n = [(x,y) | x &amp;lt;- [0..(n-1)], y &amp;lt;- [0..(n-1)]]-- Example function invocationsproductLarge3 [8, 3, 2, 5, 1]getAllCoordinates 5Note: Haskell functions do not require parameters if they simply reuse other functions, like productLarge3 above.The syntax is beyond the scope of this post.If you are unable to understand the syntax above, fret not. They are the same functions as the following in C++,int productLarge3(vector&amp;lt;int&amp;gt; arr) { sort(arr.begin(), arr.end()); reverse(arr.begin(), arr.end()); auto largest3Elements = vector&amp;lt;int&amp;gt;(arr.begin(), arr.begin() + 3); int product = 1; for (auto it : largest3Elements) { product *= it; } return product;}vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; getAllCoordinates(int n) { vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; coordinates; for (int x = 0; x &amp;lt; n; x++) { for (int y = 0; y &amp;lt; n; y++) { coordinates.push_back({x, y}); } } return coordinates;}One of things that immediately strike me is how easy it is to compose functions together in Haskell. In Haskell‚ÄôsproductLarge3 the operation of sorting and reversing an array is as simple as reverse . sort. In C++, there is theextra overhead of .begin() and .end() calls. Each statement in the imperative method corresponds to a single wordin Declarative. We can go the extra mile and define a helper function for every action done in C++,vector&amp;lt;int&amp;gt; sortArray(vector&amp;lt;int&amp;gt; arr) { sort(arr.begin(), arr.end()); return arr;}vector&amp;lt;int&amp;gt; reverseArray(vector&amp;lt;int&amp;gt; arr) { reverse(arr.begin(), arr.end()); return arr;}vector&amp;lt;int&amp;gt; take(int n, vector&amp;lt;int&amp;gt; arr) { return vector&amp;lt;int&amp;gt;(arr.begin(), arr.begin() + n);}int product(vector&amp;lt;int&amp;gt; arr) { int product = 1; for (auto it : arr) { product *= it; } return product;}int productLarge3(vector&amp;lt;int&amp;gt; arr) { return product(take(3, reverseArray(sortArray(arr))));}In this case, the C++ definition ends up being close to Haskell‚Äôs definition with a little more overhead. The burden ofdefining these methods lies with the programmer though.Take the other example of getAllCoordinates . Haskell allows you to useset builder notation to generate the result.In imperative, the only way to do this is by using loops. Note that even Haskell has to internally represent the functionas loops. It is just syntactic sugar that helps programs look closer to the problem domain. This point might seem pettyfor many folks, but the benefits really add up over larger codebases.Powerful standard librariesEmphasizing the point again, some languages make writing declarative programs easier. One important requirement forthis is to have a great set of standard library utilities that make it easier to work with the problem domain.Haskell has a gigantic set of standard libraries, which have its own search engineto find the function you want. Having a great standard library alone does not solve the problem, take Java forinstance. It has an amazing standard library but does not allow you to compose logic elements as easily as Haskelldoes. Streams API is the right step towards declarative, but it is still declarative code in a largely imperative world.Define the problem domainA language needs to only solve effortlessly in its intended problem domain. Haskell is a general programming language,so it works great on primitive data types, arrays, maps, and other standard data structures. If we try to solve for adifferent domain using Haskell, say compilers (with data types like symbol tables, abstract syntax trees, etc), we haveto define the required functions and classes (or the loose Haskell equivalent of ADTs) to make the code expressive. The most popular functional programming language in the world is Excel. ‚Äî Someone at Microsoft.Unbeknownst to most, SQL and Excel are declarative programming languages. Think about it, the following SQL statementselect name from employee where hire_date &amp;gt; &#39;2021/01/01&#39;is similar to this Java statement,// Does not compile, only for representative purposesemployees.stream().filter(employee -&amp;gt; employee.getHireDate().isAfter(&quot;2021/01/01&quot;)).map(item -&amp;gt; item.getName()).collect(Collectors.toList())The advantage of SQL is that it is specialized to the domain of querying over tables. It is not very useful ormaintainable to perform anything outside its domain of tables (e.g., handling JSON data). SQL queries express logicin syntax matching the human language solution, which for this example is ‚ÄúGet all names of employees who were hiredafter 1st Jan, 2021.‚ÄùA Pleasant Consequence ‚Äî Pure Functions!A function is pure if, It always returns the same output for a given set of input parameters. This is possible when the function‚Äôsresult depends only on its input parameters and constants. It has no side effects i.e., the function does not modify the input parameters, or any variables outside of itself.When sticking to the definition of Declarative Programming, this is pretty obvious. We never intend to computedifferent values for the same input at different points of time when defining a solution. Unless explicitly specifiedin the problem, we never expect the solution to modify the state of anything outside of the function itself. Somedeviations are when the problem requires us to update a file or read dynamically from a file.All real world solutions are mostly pure, and programs should ideally reflect this if they intend to be declarative.This also improves the reliability of programs, you can always be sure the function will return the same result foridentical inputs.Obligatory xkcd: https://xkcd.com/1312/Note: One perceived distinction is random numbers. Programs that depend on random numbers are expected to returndifferent values on every run. However, computers cannot generate truly random numbers, only pseudo-random numbers.These random number generators also take inputs such as system time. As long as even these inputs are constant (whichis infinitely improbable), the output will be the same.Conclusion ‚ÄúRepresentation is the essence of programming.‚Äù ‚Äî Fred BrooksDeclarative Programming is writing code along the lines of the human language definition of the solution. It has moreto do with how we write programs than which language we are using. It is possible to write imperative code indeclarative languages and vice-versa. Although some languages make it much easier to write programs declaratively, youcan always strive to write declarative programs in every language.This post is not trying to say that writing imperative code is wrong. Imperative programming shines when you need fullcontrol for performance-reliant programs. For the rest of the population, expressing your programs declaratively issomething to consider.‚ú® Follow me on Twitter to read more of my tech explorations :)" }, { "title": "Control your npm dependencies", "url": "/posts/Control-Your-NPM-Dependencies/", "categories": "JavaScript", "tags": "", "date": "2021-12-05 09:00:00 +0530", "snippet": "BackgroundInitializing a new react application using create-react-app installs 1900 packages, while the package.json onlydefines 23 dev dependencies. A fresh angular app uses the same number of direct dependencies and installs 1029packages. This is the minimum number of packages where many developers start their projects. The only way forwardis more dependencies.As per GitHub‚Äôs State of the Octoverse 2020 security report, the mean JavaScript repository has 10 direct dependenciesand 683 transitive dependencies (dependencies of dependencies). PHP comes second with 9 direct dependencies and 70transitive dependencies. The npm ecosystem can be accurately defined by this popular xkcd,Source: https://xkcd.com/2347/The harsh truth is that maintaining open source packages is unrewarding hard work. No one can be held accountableto fix vulnerabilities or critical issues in OS packages. In 2016, the left-pad npm package was deleted from npm byits maintainer, causing thousands of projects to break worldwide. Such incidents and security vulnerabilities becomefrequent with an increasing number of dependencies. This is not a problem that can be deferred to the future.Why are there so many transitive dependencies?Let‚Äôs look at some npm packages before going through the reasons, isarray has 53 million weekly downloads and 812 dependent packages. This is the only function exported by the library, module.exports = Array.isArray || function (arr) { return {}.toString.call(arr) === &#39;[object Array]&#39;; }; is-number has 55 million weekly downloads and 833 dependent packages. It exports a 7 line function. is-windows with 18 million weekly downloads and 615 dependent packagesexports only the following function, return process &amp;amp;&amp;amp; (process.platform === &#39;win32&#39; || /^(msys|cygwin)$/.test(process.env.OSTYPE)); is-promise has 10 million weekly downloads and 818 dependent packages.Again, this exports a single line function. is-even has 160k weekly downloads and itself depends onis-odd, which has 430k weekly downloads. Both of these packages are singleline functions. At one point, babel was using the is-odd package. The numbers are taken as of 4th Dec, 2021.These examples are only a demonstration of the extent of the problem. There are probably some useful single-linefunction packages. Similarly, there could be packages with a good number of lines that do not necessarily do anythingjustifiably useful.That is how we ended up here. A ton of tiny packages.This is not a problem found in other languages. PHP is miles away with only 70 mean transitive dependencies. One of themain reasons for this is the lack of a good standard library in JavaScript. Most of these little packages aregenerally substitutes for basic utility functions. Java has extensive in-built libraries that give performant andcorrect utility functions. So do C++ and PHP. JavaScript did not have a good standard library, which ended up drivingdevelopers to depend on external libraries for trivial tasks. In the language‚Äôs defense, utility functions have beencontinuously improved with every ECMAScript version.How does this affect us?We live in a privileged time where a 2GB node_modules directory is acceptable. Memory is no longer a constraint,but as shown in the xkcd it only takes one stone to bring your project to its feet.Packages can disappearWhile we cherish Open Source for its benefits, we should also be wary of its downsides. One fine day in 2016, themaintainer of a widely used package, left-pad, unpublished all of their packages from npm. They had valid reasons todo so, but this left the world scrambling as this tiny 7-line package was a dependency for some major packages likeReact. Although npm has long since disabled unpublishing popular packages with no prior notice, there are noguarantees for obscure packages.Abandoned packagesMost package owners create their packages out of necessity. After a point, they no longer see any benefit inmaintaining their packages. They usually have to deal with a day job even if they decide to actively maintain it.Such packages either thrive on external contributors or die out slowly, leading to possibly unhandled vulnerabilities.A package can end up abandoned within a year, given the velocity of the JavaScript ecosystem.Inadvertent errorsMost package users do not pin their dependency versions, which enables automatic upgrade of minor versions wheneveravailable. While in most cases this works fine, there have been cases where this caused issues. In Apr 2020, a minorrelease was deployed for the package is-promise, which hadunintended bugs causing most of its dependentsto break. Even though this was fixed within 3 hours, it should serve as a cautionary tale.Malicious actorsPackage maintainers are not always well-intentioned. The owner of the popular package, ua-parser-js, transferred theirpackage ownership to another user who used their privileges to publish malware using a postinstall script. npm tookdown these malicious packages within a few hours, but the damage was done.Reducing the number of dependencies used helps reduce the surface area for such issues to arise.How can we solve this?Stop using dependencies for simple tasksWrite your own methods for minor tasks such as checking the type of a variable or manipulating a string, insteadof depending on a package. Prefer implementing the feature if it takes less than 10 minutes to do so. If this is notan option or if the resulting code is hard to maintain, prefer using packages that bundle common utilities, such aslodash or underscore.js. You should use a trigonometry dependencyinstead of one for cosine.Prefer packages with less number of transitive dependenciesMost of the above-mentioned problems cannot be fixed if they are transitive dependencies. A broken transitive dependencywould mean that the direct dependency needs to be updated first before the direct dependency can be updated. If possible,choose a package with no dependencies. Otherwise, choose the ones with the least number of dependencies. Prefer packageswith a higher number of dependents as this can guarantee any vulnerabilities to be fixed soon.If the dependencies are justified and the risks are considered, feel free to use any number of them!ConclusionThis is a deeply rooted problem that is not easily solvable even though I‚Äôve listed ‚Äúsolutions‚Äù. Most dependencies innode_modules come as transitive dependencies, which cannot be avoided or controlled. The best we can do is raiseawareness of the dangers of including packages recklessly.Please remember that all of these are opinions and ideas of a single person. So, feel free to correct me!Follow me on Twitter :)Sources https://www.reddit.com/r/programming/ https://blog.npmjs.org/post/141577284765/kik-left-pad-and-npm https://blog.npmjs.org/post/141905368000/changes-to-npms-unpublish-policy https://github.com/then/is-promise/issues/13 https://github.com/faisalman/ua-parser-js/issues/536 https://javascript.plainenglish.io/is-promise-post-mortem-cab807f18dcc https://www.npmjs.com/" }, { "title": "Playing Tic-Tac-Toe as the world watches ‚Äî An introduction to BlockChain and State Channels (Part 2)", "url": "/posts/TIc-Tac-Toe-Blockchain-2/", "categories": "Blockchain", "tags": "", "date": "2020-08-15 09:00:00 +0530", "snippet": "IntroductionThis two-part series is a brief introduction to the concepts of Ethereum and State Channels by building a Tic-Tac-Toeapplication. Read Part 1 here.You have solved all the conventional issues of playing a bet match of Tic-Tac-Toe with the use of Smart Contracts onthe Ethereum network. Now, you are facing foundational problems of a Blockchain itself which are speed and cost oftransactions.Why are transactions on Blockchain slow?A Blockchain is fundamentally a set of blocks and each block is made up of transactions. Only transactions includedin blocks are considered to be valid. A block can consist of a predefined number of transactions only. In Ethereum,the average number of transactions in a block is 70 and the average block creation time is around 13 seconds. Onemay ask, why not just create blocks instantly? To create a block i.e., validate a set of transactions, one needs tosolve an extremely difficult cryptographic puzzle which takes a considerable amount of time. This process is known asmining.When a Blockchain experiences high traffic, the transactions are destined to wait for long periods of time by the designitself. Even if there are no other transactions waiting to be processed, there is a minimum time for the transaction tobe included into a block. To make things even worse, the decentralized nature of a Blockchain can cause multiple miners(ones who create blocks) from different parts of the world to create blocks containing similar transactions. Only oneof these blocks will be accepted into the Blockchain and the other blocks get discarded.Read more on resolving forks here.To make sure that a block B containing a transaction is definitely included in the blockchain and accepted by thenetwork, it is advised to wait for a minimum number of blocks (6 blocks in Bitcoin, which takes around 1 hour) to becreated after B. The affirmation that a block will not be revoked once added to the blockchain is known as Finality.Ethereum has a finality time of 2.5 minutes.Why are transactions on Blockchain expensive?As mentioned before, the miners need to solve a cryptographic puzzle using their computers to create a block andinclude your transaction. Computers need electricity and hardware, neither of which are free. To make the act ofmining profitable, the transactions require a transaction fee (gas in Ethereum) which the miner gets rewarded. Hence,the transaction fee depends on various factors such as average electricity and hardware costs to perform mining. Note: The earlier technical details are not required to understand the following sections.The SolutionDon‚Äôt use a Blockchain to solve petty problems.Not every piece of information needs to be on the Blockchain. Identifying what needs to go on a Blockchain iscrucial. Do we really need the world to watch ‚Äúeverything‚Äù?The stages in which we need the intervention of a smart contract are, Initial Funding ‚Äî The smart contract needs to store the bets before the game begins to ensure that even if oneplayer is malicious, he/she is penalized. Invalid move ‚Äî When a player makes an invalid move, such as making multiple actions (crossing off multipleboxes) in one turn, or not making a move at all, the smart contract needs to be able to act as a judge and penalizethe act. Inactivity ‚ÄîThe smart contract needs to take the correct decision when a player refuses to make the next move. Withdrawing ‚Äî At the end of the game, based on the verdict, the funds need to be distributed.Not so surprisingly, these were the issues we began with! We need to design a Smart Contract to solve only theseproblems and nothing more.Since the Smart Contract will no longer track and validate every state transition of the Tic-Tac-Toe board, how do theplayers know what the current state of the board is? We use a messaging channel between players to exchange playermoves and updated board states.This brings up a crucial problem, how do we prove that there is no impersonation? How do we prove that if one receivesa message from Alice, the message is actually created and sent by Alice?Digital SignaturesEvery Ethereum account is identified by a private/public key. These keys have one peculiar property. It is possibleto encrypt any data with the public key and this encryption can only be reversed with the private key. This is knownas asymmetric key encryption. Interestingly, the reverse isalso possible.We can encrypt data with the private key which can only be reversed by the corresponding public key. This forms thebasis of digital signatures. One can encrypt a publicly known message using the private key (which is only known tothe owner of the account). Anyone can now decrypt the encrypted message using the sender‚Äôs public key and verify thatthe sender possesses the private key i.e., it is actually the owner of the public key.Before sending any move as a message, the player can simply attach a digital signature (i.e., encryption of messageusing private key) of the move to prove that he is not being impersonated.For convenience, the game can be divided into a set of states,Intent StateBefore a game even begins, the players need to share an intent to play a game together. Alice and Bob will each createa message of the following format and send to their opponent.state: &quot;INTENT&quot;playerAddress: &quot;&amp;lt;Player&#39;s Ethereum Public Key Here&amp;gt;&quot;betAmount: 10state: &quot;&amp;lt;Initial state of the tic-tac-toe board&amp;gt;&quot;contractAddress: &quot;&amp;lt;Address at which the smart contract is hosted&amp;gt;&quot;In this message, only the address is allowed to be different for the player intents. Otherwise, the intent isdiscarded. contractAddress is the agreed upon smart contract to be used. Once a player receives and sends anintent he agrees with, it is decided that the game is happening.Depositing FundsPlayers will now call deposit() function on the smart contract and deposit the bet amounts.deposit(Intent senderIntent, Intent opponentIntent) { require(hasValidSignature(senderIntent) &amp;amp;&amp;amp; hasValidSignature(opponentIntent)); // Check if the intents are matching in all fields except playerAddress require(areValidIntents(senderIntent, opponentIntent)); require(sender == senderIntent.address); require(sender.amountSent == senderIntent.betAmount); if (!aliceHasDepositedFund) { // The first player depositing will be called Alice aliceHasDepositedFunds = true; alice = senderIntent.address; } else { // The second player will be called Bob bobHasDepositedFunds = true; bob = senderIntent.address; }}The first player depositing the betAmount is assigned as Alice, and the next player will be Bob. The function requiresintents of both players before accepting any funds.Move StateOnce both players see that the bets have been deposited by checking the state of the Smart Contract, Alice makes herfirst move and sends a message of the following format to Bob along with the digital signature through the messagingchannel.type: &quot;MOVE&quot;state: &quot;&amp;lt;Board state after making the first move&amp;gt;&quot;turn: 1player: &quot;&amp;lt;Alice&#39;s public key&amp;gt;&quot; Note: Reading the state (variables) of a Smart Contract do not need a transaction. Only state modificationsrequire a transaction.Bob makes the next move in a similar way.type: &quot;MOVE&quot;state: &quot;&amp;lt;Board state after making the second move&amp;gt;&quot;turn: 1player: &quot;&amp;lt;Bob&#39;s public key&amp;gt;&quot;Since, both players are friendly, the game continues in a fair manner. Note: One turn consists of two moves, first by Alice and then by Bob.The game proceeds with incrementing turn numbers. At the final turn, considering Alice wins, she makes the last move.WithdrawEither of the players can call the withdraw() function (once the final move of the game is done) on the smartcontract by sending the last two moves of the game.withdraw(Move preFinalMove, Move finalMove) { // Before executing, // 1. Check if signatures are correct // 2. Check if finalMove has a final board state // i.e., no more move can be performed. // 3. Check if preFinalMove -&amp;gt; finalMove is a valid transition require(isGameOver == false); isGameOver = true; if (aliceHasWon(finalMove)) { sendAmount(alice, betAmount + betAmount); } else if (bobHasWon(finalMove)) { sendAmount(bob, betAmount + betAmount); } else { // Game has tied. sendAmount(alice, betAmount); sendAmount(bob, betAmount); }}The last two moves, one by each player, are required to avoid a single player from unanimously creating a final moveand withdrawing funds.What happens when a player makes an invalid move or stays inactive?Players can always reject invalid moves by the opponent. Hence, it can be considered to be a special case of opponentinactivity, where the other player refuses to make a valid move. In these scenarios, the active player can call thereportInactivity() function of the Smart Contract by sending the move made by him and the last move made by opponent.// Assigning a dummy address 0 initially.address inactivePlayer = address(0);Move lastMove = null;reportInactivity(Move currentMove, Move lastOpponentMove) { // Check if, // 1. Signatures are valid. // 2. lastOpponentMove -&amp;gt; currentMove is a single valid move inactivePlayer = lastOpponentMove.player; lastMove = currentMove;}If Bob decides to make a valid move now, he can call the respond() function with the next valid move.Move respondMove = null;respond(Move nextMove) { // Check if // 1. Signature is valid. // 2. The sender is the inactivePlayer. require(sender == inactivePlayer); // 3. Valid single transition from lastMove -&amp;gt; nextMove. respondMove = nextMove; inactivePlayer = address(0); lastMove = null;}Alice can now read Bob‚Äôs next move from the respondMove variable in state. If Bob does not make a move even after apredefined waiting period (say 10 minutes), Alice can withdraw both players bets.withdrawInactivity() { // Check if game is not already over i.e., funds have // not already been withdrawn. // Check if it&#39;s been atleast 10 minutes since inactivity // has been reported. isGameOver = true; if (inactivePlayer == alice) { sendAmount(bob, betAmount + betAmount); } else { sendAmount(alice, betAmount + betAmount); }} Note: reportInactivity can be generalized to accept intents as well, to handle the situation where one playerdeposits funds, but the other does not.The following flowchart summarizes the state transitions of the game.Hence, the Smart Contract acts like a third-party which only gets involved to start the game, end the game andhandle any disagreements between the players.When players are fair to each other, only three transactions in total need to be made to the Blockchain. Deposit of bet by Alice before the game begins. Deposit of bet by Bob before the game begins. Withdrawing of bets once the game is over.This drastically improves the performance of the game.Speed: Every move is almost instantaneous, since we do not need to make the move on Ethereum.Cost: The players only need to pay the transaction fee for three transactions, which is a significantimprovement than the earlier approach.This concept is not a new idea in the Blockchain space. You have developed what is known as a State Channel.A State Channel involves creating a channel between two or more parties where state updates can be exchangeddirectly and a smart contract only handles the disputes.Read more on State Channels here.This specific example of tic-tac-toe is inspired by a State Channel protocol called Force Move.Read here.Thanks for reading!" }, { "title": "Playing Tic-Tac-Toe as the world watches ‚Äî An introduction to BlockChain and State Channels (Part 1)", "url": "/posts/Tic-Tac-Toe-Blockchain-1/", "categories": "Blockchain", "tags": "", "date": "2020-08-02 09:00:00 +0530", "snippet": "IntroductionThis 2-part series is a brief introduction to the concepts of Ethereum and State Channels by building atic-tac-toe application.Stuck in the lock-down, you have been whiling away time playing the game of tic-tac-toe with your friend for monthsnow and it has become monotonous. To spice things up, you both have decided to bet some money and winner takes it all.But, with money comes problems.You cannot trust your friend to be able to afford the bet.You cannot trust your friend to make a valid move.You cannot trust your friend to complete the game.You cannot trust your friend to honor the bet if you win.You decide to solve each problem. Firstly, how do we prove that a player can afford a bet? You can ask him to submitthe funds before even the game begins. But,He does not trust you to keep the funds safe and distribute fairly. Neither do you trust him with that responsibility.You read up online for a solution to these problems and come across the following topics,Note: Feel free to skip the sections you are familiar with.BlockchainIn layman terms, a Blockchain is a decentralized network that allows one to make transactions (i.e., transfer of fundsor data between users) in such a way that no single entity (a bank or a person) can control or tamper. In a Blockchain,all transactions are completely public, so you can check the balance of your friend yourself and make sure that he‚Äôllbe able to afford it.Read more on Blockchain here.Multi-Signature WalletsA Blockchain transaction requires the owner of the account/wallet to prove that they are the one making thetransaction, similar to how one has to enter the UPI PIN on any UPI app before making a payment. Unlike traditionalblockchain wallets that belong to a single person, a Multi-Signature wallet is owned by multiple people. Before makinga transaction from the wallet, all the owners of the wallet need to agree to make the transaction.Read more on Multi-Signature Wallets here.A Multi-Sig wallet can solve the responsibility of keeping funds! How? You create a Multi-Signature wallet betweenthe players and both of you can send your bets to the shared wallet. Now, no single player can unilaterally withdrawfunds. Unless the withdrawing transaction created is accepted by both participants, it will not be executed. Thus,the funds are safe.There is still the problem of players making an invalid move. You do further reading and stumble upon some more topics,EthereumEthereum is yet another Blockchain BUT it does not limit itself to monetary transactions like Bitcoin. It can executeany programmable function in such a way that no one entity can tamper the output. The output of the function isverified by the entire network of Ethereum users.The Ethereum Blockchain can be viewed as a large computation engine which is guaranteed to give correct results everytime. But, it is not free. You are expected to pay a fee (called gas) to do the computation. The gas is directlyproportional to the number of instructions of the function you are trying to execute.Read more on Ethereum here.Smart ContractsFunctions to be computed by the Ethereum network is written in the form of Smart Contracts. Consider a Smart Contractto be a literal replacement for real life contracts. Once a real life contract is in place, the specified rules arestrictly adhered to, and in case of deviations, law enforcement is involved. Similarly, smart contracts define a set ofrules in the form of a program, and also makes it impossible to make any deviation from the rules. It can go above andbeyond a real-life contract and act as a third-party entity.A Smart Contract can store funds (Ether in Ethereum) and distribute them. Hence, it can act as a multi signature walletbut also allow a single or set of owners to withdraw unilaterally when specific conditions are met according to thecontract. Every smart contract has a state to store variables and use them, such as the current tic-tac-toe boardstate.Note: Going further, you will be called Alice and your friend will be called Bob. So, hello Alice!This is perfect! You can now solve the problem of trusting Bob to always make a valid move and completing the gameusing a smart contract. Smart Contracts are written in the Solidity language. You can write and deploy a SmartContract that looks like this,contract TicTacToe { // currentState contains the current board state // i.e., List of the 3*3 tiles and which ones have // been marked by whom State currentState; // Wallet addresses of Alice and Bob Address alice; Addess bob; int betAmount = 10; // This stores who has previously made a move. Address previouslyMoved; // Time at which last move was done. Time lastMoveTime; bool aliceHasDepositedFunds = false; bool bobHasDepositedFunds = false; bool isGameOver = false; // This constructor is called when the contract is created. TicTacToe(Address _alice, Address _bob) { alice = _alice; bob = _bob; // Since the first move is to be done by alice, // We will set bob to have moved previously previouslyMoved = _bob; } depositFunds() { // If a require condition fails, // the function terminates and does not proceed require(amountSent == betAmount); // sender is an inbuilt variable that has the // address of the person calling the function. if (sender == alice) { aliceHasDepositedFunds = true; } else if (sender == bob) { bobHasDepositedFunds = true; } } move(State nextState) { require(aliceHasDepositedFunds &amp;amp;&amp;amp; bobHasDepositedFunds); require(!isGameOver); // Check if the same person is not making a move twice. require(isCorrectPersonMakingTheMove(sender, previouslyMoved)); // Check if given two consecutive states is a valid transition. require(isValidMove(currentState, nextState)); currentState = nextState; previouslyMoved = sender; lastMoveTime = getCurrentTime(); if (isGameTied(currentState)) { // No more valid moves are left sendAmount(alice, betAmount); sendAmount(bob, betAmount); isGameOver = true; } else if (hasGameEnded(currentState)) { // sender has made the last move, and won the game sendAmount(sender, betAmount + betAmount); isGameOver = true; } } // Function to be called when the other player // is refusing to make a move. reportInactivity() { if ((getCurrentTime() - lastMoveTime) &amp;gt; &quot;10 minutes&quot;) { sendAmount(previouslyMoved, betAmount + betAmount); isGameOver = true; } } isValidMove(State currentState, State nextState) { // You can define a set of rules to validate // two consecutive tic-tac-toe moves } sendAmount(Address recipient, int amount) { // Sends amount to recipient. }} It is not required to understand the code completely to follow the remaining sections. Note: The above code is not a proper syntax of any language. It is meant as a cross between C++, pseudocode andSolidity for familiarity.You have now created a smart contract and deployed it on the Ethereum network using tools such asRemix and Metamask.Your friend needs to be briefed about how it works as well. This is how it should work when both players are honest.When Bob tries to make an invalid move,When bob is not willing to make the next move, delays the next move or tries to lock the funds forever in the contract,You have ended up solving the following problems, You need not trust that the opponent has the required funds because the game does not start without both playersdepositing. You can always expect the opponent to make a valid move. If the opponent does not make a valid move, he loses allhis bet. You are guaranteed to be paid by the opponent (if you win), since the funds are locked before the game even begins. You no longer need to entrust a third party to fairly distribute the funds, since the smart contract, whose rulesare written in stone, handles the distribution.You have solved the initial problems and have started playing the game. But, there are other major problems!Speed: An Ethereum transaction can take anywhere from 15 seconds to 5 minutes to process a transaction.Imagine waiting for 5 minutes after every move on a simple tic-tac-toe game.Cost: Computation on Ethereum is not free. As already mentioned, we need to pay a certain amount of transaction feeand every move is a transaction. The average Ethereum transaction fee is 1.59$. This will be incurred on every turn,including the initial deposit!More problems to solve :DThanks for reading!In the next part, we‚Äôll be elucidating about a concept called State Channels that make game moves instantaneouslywith just one or two transactions to Ethereum while maintaining all the existing benefits.Also, the code has its logical flaws. I had to make a trade-off between correctness and simplicity." } ]
